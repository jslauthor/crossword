const schema = {
  seed: 840275,
  items: {
    '🍕': "Circular delight that's anything but square",
    '🌈': "Nature's Instagram filter after a good cry",
    '🦋': 'Winged fashion icon of the insect world',
    '🚀': "Elon Musk's favorite way to dodge traffic",
    '🎭': "Two-faced performers that aren't being shady",
    '🏆': 'Shiny shelf ornament for the competitive',
    '🌻': 'Tall, golden-headed admirer of Sol',
    '🍦': "Dairy queen's scepter on a summer day",
    '🎸': 'Six-stringed attention seeker at parties',
    '🐘': 'Gentle giant with built-in water hose',
    '🌋': "Earth's temperamental pimple",
    '🧺': 'Where grains go for spring break',
    '🎨': "Jackson Pollock's favorite dinner plate",
    '🚲': null,
    '🍄': null,
    '🦉': null,
    '🈶': null,
    '🧩': null,
    '🎻': null,
    '🌮': null,
    '🧲': null,
    '🦜': null,
    '🤪': null,
    '🥇': null,
    '📅': null,
    '🦷': null,
  },
  grid: [
    [1, 0, 1, 0, 1],
    [0, 1, 0, 1, 0],
    [1, 0, 1, 0, 1],
    [0, 1, 0, 1, 0],
    [1, 0, 1, 0, 1],
  ],
  metadata: {
    0: {
      styles: ['circled'],
      related: [2, 3, 5],
    },
  },
};

function validateCrossmojiSchema(schema) {
  const validEmojis =
    '🀄🃏🆎🆑🆒🆓🆔🆕🆖🆗🆘🆙🆚🈁🈂🈚🈯🈲🈳🈴🈵🈶🈷🈸🈹🈺🉐🉑🌀🌁🌂🌃🌄🌅🌆🌇🌈🌉🌊🌋🌌🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝🌞🌟🌠🌡🌤🌥🌦🌧🌨🌩🌪🌫🌬🌭🌮🌯🌰🌱🌲🌳🌴🌵🌶🌷🌸🌹🌺🌻🌼🌽🌾🌿🍀🍁🍂🍃🍄🍅🍆🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍔🍕🍖🍗🍘🍙🍚🍛🍜🍝🍞🍟🍠🍡🍢🍣🍤🍥🍦🍧🍨🍩🍪🍫🍬🍭🍮🍯🍰🍱🍲🍳🍴🍵🍶🍷🍸🍹🍺🍻🍼🍽🍾🍿🎀🎁🎂🎃🎄🎅🎆🎇🎈🎉🎊🎋🎌🎍🎎🎏🎐🎑🎒🎓🎖🎗🎙🎚🎛🎞🎟🎠🎡🎢🎣🎤🎥🎦🎧🎨🎩🎪🎫🎬🎭🎮🎯🎰🎱🎲🎳🎴🎵🎶🎷🎸🎹🎺🎻🎼🎽🎾🎿🏀🏁🏂🏃🏄🏅🏆🏇🏈🏉🏊🏋🏌🏍🏎🏏🏐🏑🏒🏓🏔🏕🏖🏗🏘🏙🏚🏛🏜🏝🏞🏟🏠🏡🏢🏣🏤🏥🏦🏧🏨🏩🏪🏫🏬🏭🏮🏯🏰🏳🏴🏵🏷🏸🏹🐀🐁🐂🐃🐄🐅🐆🐇🐈🐉🐊🐋🐌🐍🐎🐏🐐🐑🐒🐓🐔🐕🐖🐗🐘🐙🐚🐛🐜🐝🐞🐟🐠🐡🐢🐣🐤���🐦🐧🐨🐩🐪🐫🐬🐭🐮🐯🐰🐱🐲🐳🐴🐵🐶🐷🐸🐹🐺🐻🐼🐽🐾🐿👀👁👂👃👄👅👆👇👈👉👊👋👌👍👎👏👐👑👒👓👔👕👖👗👘👙👚👛👜👝👞👟👠👡👢👣👤👥👦👧👨👩👪👫👬👭👮👯👰👱👲👳👴👵👶👷👸👹👺👻👼👽👾👿💀💁💂💃💄💅💆💇💈💉💊💋💌💍💎💏💐💑💒💓💔💕💖💗💘💙💚💛💜💝💞💟💠💡💢💣💤💥💦💧💨💩💪💫💬💭💮💯💰💱💲💳💴💵💶💷💸💹💺💻💼💽💾💿📀📁📂📃📄📅📆📇📈📉📊📋📌📍📎📏📐📑📒📓📔📕📖📗📘📙📚📛📜📝📞📟📠📡📢📣📤📥📦📧📨📩📪📫📬📭📮📯📰📱📲📳📴📵📶📷📸📹📺📻📼📽📿🔀🔁🔂🔃🔄🔅🔆🔇🔈🔉🔊🔋🔌🔍🔎🔏🔐🔑🔒🔓🔔🔕🔖🔗🔘🔙🔚🔛🔜🔝🔞🔟🔠🔡🔢🔣🔤🔥🔦🔧🔨🔩🔪🔫🔬🔭🔮🔯🔰🔱🔲🔳🔴🔵🔶🔷🔸🔹🔺🔻🔼🔽🕉🕊🕋🕌🕍🕎🕐🕑🕒🕓🕔🕕🕖🕗🕘🕙🕚🕛🕜🕝🕞🕟🕠🕡🕢🕣🕤🕥🕦🕧🕯🕰🕳🕴🕵🕶🕷🕸🕹🕺🖇🖊🖋🖌🖍🖐🖕🖖🖤🖥🖨🖱🖲🖼🗂🗃🗄🗑🗒🗓🗜🗝��🗡🗣🗨🗯🗳🗺🗻🗼🗽🗾🗿😀😁😂😃😄😅😆😇😈😉😊😋😌😍😎😏😐😑😒😓😔😕😖😗😘😙😚😛😜😝😞😟😠😡😢😣😤😥😦😧😨😩😪😫😬😭😮😯😰😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙁🙂🙃🙄🙅🙆🙇🙈🙉🙊🙋🙌🙍🙎🙏🚀🚁🚂🚃🚄🚅🚆🚇🚈🚉🚊🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🚚🚛🚜🚝🚞🚟🚠🚡🚢🚣🚤🚥🚦🚧🚨🚩🚪🚫🚬🚭🚮🚯🚰🚱🚲🚳🚴🚵🚶🚷🚸🚹🚺🚻🚼🚽🚾🚿🛀🛁🛂🛃🛄🛅🛋🛌🛍🛎🛏🛐🛑🛒🛕🛖🛗🛜🛝🛞🛟🛠🛡🛢🛣🛤🛥🛩🛫🛬🛰🛳🛴🛵🛶🛷🛸🛹🛺🛻🛼🟠🟡🟢🟣🟤🟥🟦🟧🟨🟩🟪🟫🟰🤌🤍🤎🤏🤐🤑🤒🤓🤔🤕🤖🤗🤘🤙🤚🤛🤜🤝🤞🤟🤠🤡🤢🤣🤤🤥🤦🤧🤨🤩🤪🤫🤬🤭🤮🤯🤰🤱🤲🤳🤴🤵🤶🤷🤸🤹🤺🤼🤽🤾🤿🥀🥁🥂🥃🥄🥅🥇🥈🥉🥊🥋🥌🥍🥎🥏🥐🥑🥒🥓🥔🥕🥖🥗🥘🥙🥚🥛🥜🥝🥞🥟🥠🥡🥢🥣🥤🥥🥦🥧🥨🥩🥪🥫🥬🥭🥮🥯🥰🥱🥲🥳🥴🥵🥶🥷🥸🥹🥺🥻🥼🥽🥾🥿🦀🦁🦂🦃🦄🦅🦆🦇🦈🦉🦊🦋🦌🦍🦎🦏🦐🦑🦒🦓🦔🦕🦖🦗🦘🦙🦚🦛🦜🦝🦞🦟🦠🦡🦢🦣🦤🦥🦦🦧🦨🦩🦪🦫🦬🦭🦮🦯🦰🦱🦲🦳🦴🦵🦶🦷🦸🦹🦺🦻🦼🦽🦾🦿🧀🧁🧂🧃🧄🧅🧆🧇🧈🧉🧊🧋🧌🧍🧎🧏🧐🧑🧒🧓🧔🧕🧖🧗🧘🧙🧚🧛🧜🧝🧞🧟🧠🧡🧢🧣🧤🧥🧦🧧🧨🧩🧪🧫🧬🧭🧮🧯🧰🧱🧲🧳🧴🧵🧶🧷🧸🧹🧺🧻🧼🧽🧾🧿🩰🩱🩲🩳🩴🩵🩶🩷🩸🩹🩺🩻🩼🩽🩿🫀🫁🫂🫃🫄🫅🫎🫏🫐🫑🫒🫓🫔🫕🫖🫗🫘🫙🫚🫛🫠🫡🫢🫣🫤🫥🫦🫧🫨🫰🫱🫲🫳🫴🫵🫶🫷🫸‼⌚⌛⌨⏏⏩⏪⏫⏬⏭⏮⏯⏰⏱⏲⏳⏸⏹⏺▶◀☀☁☂☃☄☎☑☔☕☘☝☠☢☣☦☪☮☯☸☹☺♀♂♈♉♊♋♌♍♎♏♐♑♒♓♟♠♣♥♦♨♻♾♿⚒⚓⚔⚕⚖⚗⚙⚛⚜⚠⚡⚧⚪⚫⚰⚱⚽⚾⛄⛅⛈⛎⛏⛑⛓⛔⛩⛪⛰⛱⛲⛳⛴⛵⛷⛸⛹⛺⛽✂✅✈✉✊✋✌✍✏✒✔✖✝✡✨✳✴❄❇❌❎❓❔❕❗❣❤➕➖➗➡⤴⤵⬅⬆⬇⭐⭕🇺🇸🇨🇳🇯🇵🇩🇪🇬🇧🇫🇷🇮🇳🇮🇹🇨🇦🇦🇺🇧🇷🇷🇺🇰🇷🇪🇸🇲🇽🇳🇱🇨🇭🇸🇪🇸🇬🇦🇪🇧🇪🇳🇴🇩🇰🇦🇹🇫🇮🇳🇿🇵🇱🇮🇪🇮🇱🇹🇷🇸🇦🇿🇦🇵🇹🇬🇷🇨🇿🇭🇺🇹🇭🇻🇳🇵🇭🇲🇾🇮🇩🇦🇷🇨🇱🇪🇬🇵🇰🇳🇬🇧🇩🇺🇦';

  function emojiToUnicode(emoji) {
    // If the emoji is already a unicode, return it
    if (emoji.charAt(0).toLowerCase() === 'u') {
      return emoji;
    }

    const codePoints = Array.from(emoji).map(
      (char) => char.codePointAt(0)?.toString(16).padStart(4, '0') || '',
    );

    return 'u' + codePoints.join('_');
  }

  if (typeof schema !== 'object' || schema === null) {
    console.error('Schema must be an object');
    return false;
  }

  // 1. Validate seed
  if (!Number.isInteger(schema.seed) || schema.seed.toString().length !== 6) {
    console.error('Seed must be a 6-digit integer');
    return false;
  }

  // 2. Validate items
  if (!schema.items) {
    console.error('Schema must have an items object');
    return false;
  }

  const uniqueItems = new Set(Object.keys(schema.items));
  if (uniqueItems.size !== 26) {
    console.error('Schema must have exactly 26 unique items');
    return false;
  }

  // 3. Validate grid and non-null items count
  const nonNullItemsCount = Object.values(schema.items).filter(
    (item) => item !== null,
  ).length;
  const gridOnesCount = schema.grid.flat().filter((cell) => cell === 1).length;
  if (nonNullItemsCount !== gridOnesCount) {
    console.error(
      'Number of non-null items must equal the number of 1s in the grid',
    );
    return false;
  }

  // 4. Validate metadata
  if (schema.metadata) {
    const itemsCount = Object.keys(schema.items).length;
    for (const key of Object.keys(schema.metadata)) {
      const index = parseInt(key, 10);
      if (isNaN(index) || index < 0 || index >= itemsCount) {
        console.error('Metadata keys must be valid indices of items');
        return false;
      }
    }
  }

  // 5. Validate item keys
  const validEmojiSet = new Set(validEmojis);
  for (const key of Object.keys(schema.items)) {
    if (typeof key !== 'string') {
      console.error('Item keys must be strings');
      return false;
    }

    // Check if the key is a valid emoji or its Unicode representation
    if (!validEmojiSet.has(key) && !validEmojiSet.has(emojiToUnicode(key))) {
      console.error(`Invalid emoji key: ${key}`);
      return false;
    }
  }

  return true;
}

// Example usage:
const isValid = validateCrossmojiSchema(schema);
console.log('Schema is valid:', isValid);
